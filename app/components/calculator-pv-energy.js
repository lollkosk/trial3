import Component from '@ember/component';
import { computed } from '@ember/object';

/**
  Photovoltaic energy calculator component showing a list of photovoltaics, and
  a hook to delete photovoltaics. Computes the total energy generated by given
  photovoltaics.

  @class CalculatorPvEnergy
*/
export default Component.extend({
  /**
    Converts degrees to radians.

    @method degToRad
    @param {Number} degrees
    @return radians
  */
  degToRad(degrees) {
    return (Math.PI / 180) * degrees;
  },

  /**
    Computes solar radiation on a surface for specific month given its
    orientation and elevation (tilt), based on constants for average UK values
    from the documentation at (U3.2).

    @method solarRadiationOnSurface
    @param {String} orientation - surface orientation from Photovoltaic model.
    @param {String} tilt - surface tilt from Photovoltaic model.
    @param {Number} month - month to compute for (0-11)
    @return solar radiation according to (U3.2)
  */
  solarRadiationOnSurface(orientation, tilt, month) {
    // solar irridiance for given month according to (Table U3)
    let Shm = CONSTANTS.solarIrridiance[month];

    // special case - if the orientation is horizontal then no need to compute
    // the inclination factor Rhinc
    if (orientation == 'horizontal') {
      return Shm;
    }

    // compute the inclination factor Rhinc to convert from horizontal radiation
    // Shm to inclined or vertical based on orientation and tilt
    let phi = CONSTANTS.latitude;
    let delta = CONSTANTS.solarDeclination[month];
    let cosFB = Math.cos(this.degToRad(phi - delta));// NOTE: degrees to radians

    let p = CONSTANTS.inclination[tilt];
    let sin = Math.sin(this.degToRad(p/2));// NOTE: degrees to radians

    let K = CONSTANTS.K[CONSTANTS.orientation[orientation]];
    let SIN = [sin*sin*sin, sin*sin, sin];
    let A = (K[0] * SIN[0]) + (K[1] * SIN[1]) + (K[2] * SIN[2]);
    let B = (K[3] * SIN[0]) + (K[4] * SIN[1]) + (K[5] * SIN[2]);
    let C = (K[6] * SIN[0]) + (K[7] * SIN[1]) + (K[8] * SIN[2]) + 1;
    // Rhinc according to (U2)
    let Rhinc = (A * cosFB * cosFB) + (B * cosFB) + C;

    // S (radiation for tilt and orientation) according to (U1)
    return Shm * Rhinc;
  },

  /**
    Energy generated by all PVs displayed in this component. Updates when number
    of displayed PVs change.

    Computed according to (Appendix M1) from the documentation.

    @property energy
    @type {Number}
  */
  energy: computed('photovoltaics.length', function() {
    // initialize sum to zero
    let sum = 0;

    let photovoltaics = this.get('photovoltaics');
    if(photovoltaics) {
      // sum up the energy of each photovoltaic
      photovoltaics.forEach((photovoltaic) => {
        // overshadingFactor according to (Table H2)
        let overshadingFactor = CONSTANTS.overshading[photovoltaic.overshading];

        // annualRadiation - sum for each month according to (U3.3)
        let annualRadiation = 0;
        CONSTANTS.months.forEach((days, month) => {
          annualRadiation += CONSTANTS.coeffAnnualRadiation * days * this.solarRadiationOnSurface(photovoltaic.orientation, photovoltaic.elevation, month);
        });

        // energy according to (M1)
        let e = CONSTANTS.coeffEnergy * photovoltaic.peakPower * annualRadiation * overshadingFactor;

        sum += e;
      });
    }

    // return the total energy - sum of all photovoltaics
    return sum;
  }),

  actions: {
    /**
      Handles the delete of a photovoltaic that is done by calling its action passed
      here by a parameter. Does nothing if the action is not defined.

      @method deletePhotovoltaic
      @param {Photovoltaic} photovoltaic record to delete.
      @return nothing
    */
    deletePhotovoltaic(photovoltaic) {
      // check if the delete action is defined
      if (this.onDeleteAction) {
        // call the delete action
        this.onDeleteAction(photovoltaic);
      }
    }
  }
});

/**
  Constants needed for the PV energy computations. Each described independently.
*/
const CONSTANTS = {
  // days in each month of the year, jan to dec (not-leap year)
  months: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],

  // constant numbers used in the formulas
  // M1
  coeffEnergy: 0.8,
  // U3.3
  coeffAnnualRadiation: 0.024,

  /**
    constants based on attributes of photovoltaics. translates the actual
    values in photovoltaic model to respective numbers
  */
  // orientation - translates to an index into respective row in K constants
  orientation: {
    "N": 0,
    "NE": 1,
    "E": 2,
    "SE": 3,
    "S": 4,
    "SW": 3,
    "W": 2,
    "NW": 1,
    "horizontal": -1
  },
  inclination: {
    'horizontal': 0,
    '30': 30,
    '45': 45,
    '60': 60,
    'vertical': 90,
  },
  overshading: {
    "heavy": 0.5,
    "significant": 0.65,
    "modest": 0.8,
    "none": 1
  },

  // solar irridiance and declination per month - UK average (Table U3)
  solarIrridiance: [26, 54, 96, 150, 192, 200, 189, 157, 115, 66, 33, 21],
  solarDeclination: [-20.7, -12.8, -1.8, 9.8, 18.8, 23.1, 21.2, 13.7, 2.9, -8.7, -18.4, -23.0],

  // representative latitude - UK average (Table U4)
  latitude: 53.5,

  // K values (Table U5)
  K: [
    [26.3, -38.5, 14.8, -16.5, 27.3, -11.9, -1.06, 0.0872, -0.191],
    [0.165, -3.68, 3, 6.38, -4.53, -0.405, -4.38, 4.89, -1.99],
    [1.44, -2.36, 1.07, -0.514, 1.89, -1.64, -0.542, -0.757, 0.604],
    [-2.95, 2.89, 1.17, 5.67, -3.54, -4.28, -2.72, -0.25, 3.07],
    [-0.66, -0.106, 2.93, 3.63, -0.374, -7.4, -2.71, -0.991, 4.59],
  ]
};
